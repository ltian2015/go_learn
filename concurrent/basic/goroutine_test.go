package basic

import (
	"fmt"
	"runtime"
	"sync"
	"testing"
)

/**
https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html
1.Go语言的线程模型
编程语言有几种不同的方式来实现线程。很多操作系统提供了用于创建新线程的API。
从操作系统的角度来看，编程语言所提供的线程属于“用户线程（user thread）”，操作系统直接调度的
是“内核线程（kernel thread）”。用户线程只有与操作系统线程绑定的时候才可以得到执行。
因此，编程语言所提供的用户线程与操作系统的内核线程之间存在3种映射或绑定关系：
	（1）1:1模式，就是编程语言中的每个“用户线程”都对应一个操作系统的“内核线程”。
		比如java1.3以后的版本。
	（2）M:1模式，这也被称为"传统绿色线程"的模式。该模式下，一个进程中的M个编程语言的“用户线程”对应
		1个操作系统的“内核线程”。此模型下，当1个“用户线程”进行系统调用产生了阻塞，就会导致进程中
		唯一的“内核线程”发生阻塞，进而导致进程中所有其他线程都会阻塞，也就是“进程”被阻塞。
		比如，Java1.1，Java1.2版本就是采用了这种模式。这种模式由于缺点明显,几乎已经被抛弃。
	（3）M:N模式，也就是多对多模式。该模式下，	一个进程中的M个编程语言”用户线程“对应N个”内核线程“。
		此模型下，当进程中的一个用户线程发生了阻塞式的系统调用，只会引起支持该用户线程的内核线程的阻塞，
		进程中的其他”用户线程“可以绑定其他未阻塞的”内核线程“，因此不会造成进程的整体阻塞。
		比如，golang就采用了M:N模式。

采用M：N模式需要增加一个更加庞大的语言运行时来管理这些线程。针对不同设计目标的语言的线程设计策略不同，
比如，Rust作为一种能够支持操作开发的低级语言，其标准库只提供了1:1 模型的线程实现。当然，如果想要花费一些开销以
换取诸如对用户线程何时运行，并对其进行控制以及获得更少的线程运行上下文切换的开销式，Rust语言也有一些crates
能够实现了M：N线程模式。而GO语言的目标是面向网络编程和操作系统之上的软件开发，所以GO语言采用了M:N的线程模式，
当然， 因此GO语言也带有了较大的运行库，编译后的GO程序都会带有这个运行时的库进行线程调度和垃圾回收。

2.Go语言中的“用户线程-goroutne”与操作系统内核线程的区别
在操作系统中，内核线程才是真正执行代码的工作者，因此每个内核线程必须要有一个固定大小的堆栈（1—8M）来为线程这个工作者
存储尚待完成的工作现场数据，也就是存储包括入口函数在内的每个尚未完成的嵌套函数的下个代码地址与仍在生效的局部变量。
尽管每个进程都使用虚拟内存空间，但是在进程中，正在运行的内核线程则需要使用真实的物理内存，
因此，进程中并发的内核线程数量越多，那么就要为每个运行的内核线程开辟固定大小的堆栈内存。由于操作系统没和线程的所需要的固定大小
的堆栈内存空间较大，一般都在1M—8M之间，因此，程序所能同时运行的内核线程数量是有限的。假定操作系统内核线程堆栈只需要1M内存，
一个32G内存系统中，即使全部内存都用于创建内核线程，那么最多也就能开辟32*1024个线程，而实际上，操作系统本身需要占用部分内存，
进程的程序代码、已运行的内核线程所使用堆数据也需要内存，实际上用于开辟内核线程堆栈的内存远远达不到32G，因此，可以开辟的内核线程
数量往往达不到数万。

而go语言中用户线程——goroutine并不是堆栈大小固定的操作系统内核线程，goroutine由go语言程序的运行时管理，所以goroutine的堆栈不是固定大小，
而是可以随着程序的运行动态增加与减少，goroutine堆栈往往只有几k（4K-8k），因此，go语言中可以同时运行大量的goroutine。

 *******************************************************************/

// TestHugeNumGortouineInRunning展示了一个运行1000万个goroutine的程序。
// 在16G内存，4核8线程，2.9G HZ的macbookPro电脑上，一分钟左右可完成1000万个互不相关简单线程的运行。
// 可见，Goroutine确实是一种轻量级的用户线程。
func TestHugeNumGortouineInRunning(t *testing.T) {
	const goroutineCount = 10000000 // 同时存活的线程数量
	var wg sync.WaitGroup
	//大多数时，使用WaitGroup都是控制等待所有goroutine全部完成。
	//这里使用WaitGroup等待所有goroutine全部到来，然后一起执行。类似于java的并发库中的关卡。
	wg.Add(goroutineCount)
	for i := 0; i < goroutineCount; i++ {
		go func() {
			wg.Done()  //创建一个线程，等待数量就减少1个
			wg.Wait()  //等待所有goroutine创建完毕再同时执行。
			j := i * i //执行一次平方计算
			_ = j
			//time.Sleep(10 * time.Nanosecond)

		}()
	}
	//主goroutine会一直以非阻塞的方式等待另一个线程的完成。
	//这是一种非阻塞式的协程等待方式，它不会一直占用CPU资源的自旋锁(spin lock)。
	//Gosched()与for循环配合是实现自旋锁的重要机制，自旋条件可以根据情况设定。
	//这里是存活的线程数量，自旋锁更多场景是CAS（Compare And Swap）算法中。
	for runtime.NumGoroutine() > 2 {
		runtime.Gosched() //Gosched()函数解除当前正在执行的goroutine与OS线程的绑定，从而，让出执行权，进入排队状态，等下下一次执行的机会。
	}
	fmt.Println("all goroutines terminate,the main program exit")

}
